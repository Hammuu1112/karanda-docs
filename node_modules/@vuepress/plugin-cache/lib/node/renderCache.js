import { fs, hash } from 'vuepress/utils';
import { checkIOSpeed, readFile, readFileSync, writeFile } from './utils.js';
const CACHE_DIR = 'markdown/rendered';
const META_FILE = '_metadata.json';
const CACHE_FILE = '_cache.json';
export const renderCacheWithMemory = async (md, app) => {
    if (app.env.isBuild && !fs.existsSync(app.dir.cache(CACHE_DIR))) {
        return;
    }
    const basename = app.dir.cache(CACHE_DIR);
    const metaFilepath = `${basename}/${META_FILE}`;
    const cacheFilepath = `${basename}/${CACHE_FILE}`;
    await fs.ensureDir(basename);
    const [metadata, cache] = await Promise.all([
        readFile(metaFilepath),
        readFile(cacheFilepath),
    ]).then(([metadataStore, cacheStore]) => [metadataStore ?? {}, cacheStore ?? {}]);
    let timer = null;
    const update = () => {
        if (timer)
            clearTimeout(timer);
        timer = setTimeout(() => {
            void Promise.all([
                writeFile(metaFilepath, metadata),
                writeFile(cacheFilepath, cache),
            ]);
        }, 200);
    };
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const rawRender = md.render;
    md.render = (input, env) => {
        const filepath = env.filePathRelative;
        if (!filepath) {
            return rawRender(input, env);
        }
        const key = hash(input);
        if (metadata[filepath] === key && filepath in cache) {
            const cached = cache[filepath];
            Object.assign(env, cached.env);
            return cached.content;
        }
        const content = rawRender(input, env);
        metadata[filepath] = key;
        cache[filepath] = { content, env };
        update();
        return content;
    };
};
export const renderCacheWithFilesystem = async (md, app) => {
    if (app.env.isBuild && !fs.existsSync(app.dir.cache(CACHE_DIR))) {
        return;
    }
    const basename = app.dir.cache(CACHE_DIR);
    await fs.ensureDir(basename);
    const speed = checkIOSpeed(basename);
    const metaFilepath = `${basename}/${META_FILE}`;
    const metadata = (await readFile(metaFilepath)) ?? {};
    let timer = null;
    const update = (filepath, data) => {
        void writeFile(`${basename}/${filepath}`, data);
        if (timer)
            clearTimeout(timer);
        timer = setTimeout(() => {
            void writeFile(metaFilepath, metadata);
        }, 200);
    };
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const rawRender = md.render;
    md.render = (input, env) => {
        const filepath = env.filePathRelative;
        if (!filepath) {
            return rawRender(input, env);
        }
        const key = hash(input);
        const filename = hash(filepath);
        if (metadata[filepath] === key) {
            const cached = readFileSync(`${basename}/${filename}`);
            if (cached) {
                Object.assign(env, cached.env);
                return cached.content;
            }
            metadata[filepath] = '';
        }
        const start = performance.now();
        const content = rawRender(input, env);
        /**
         * High-frequency I/O is also a time-consuming operation,
         * therefore, for render operations with low overhead, caching is not performed.
         */
        if (performance.now() - start > speed) {
            metadata[filepath] = key;
            update(filename, { content, env });
        }
        return content;
    };
};
